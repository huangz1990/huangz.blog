Go 语言中的浮点数
=====================

.. note::

    本文摘录自《Go语言趣学指南》第 6 章，
    请访问 `gpwgcn.com <http://gpwgcn.com>`_  以获取更多相关信息。

    .. image:: image/gpwgcn.jpg
       :scale: 80%

Go 语言拥有两种浮点类型，
其中默认的浮点类型为 ``float64`` ，
每个 64 位的浮点数需要占用 8 字节内存，
很多语言都使用术语双精度浮点数来描述这种浮点数。

以下是定义一个 ``float64`` 浮点数的几种不同方式，
它们具有同等的作用：

.. code:: go

    days := 365.2425    // 在第 4 章中提到过的简短声明
    var days = 365.2425
    var days float64 = 365.2425

虽然知道 ``day`` 变量的类型是有价值的，
但通过 ``float64`` 类型声明凸显这一点并不是必需的。
毕竟，
无论是我们还是 Go 编译器，
只要看一眼 ``days`` 变量右侧的值，
就能够准确无误地推断出它的类型。
在 Go 语言中，
所有带小数点的数字在默认情况下都会被设置为 ``float64`` 类型。

但是，
如果使用整数去初始化一个变量，
那么 Go 语言只有在显式地指定浮点类型的情况下，
才会将其声明为浮点类型变量:

.. code:: go

    var answer float64 = 42

Go 语言提供的另一种浮点类型是 ``float32`` ，
又称单精度浮点数，
它占用的内存只有 ``float64`` 类型占用内存的一半，
但它提供的精度不如 ``float64`` 高。
为了使用 ``float32`` 浮点数，
你必须在声明变量时指定变量类型，
就像代码清单 6-1 所示的那样。

----

代码清单 6-1 64 位的浮点数合 32 位的浮点数： ``pi.go``

.. code:: go

    var pi64 = math.Pi
    var pi32 float32 = math.Pi

    fmt.Println(pi64)   //  打印出“3.141592653589793”
    fmt.Println(pi32)   //  打印出“3.1415927”

在处理诸如三维游戏中的数千个顶点这样数量庞大的数据时，
使用 ``float32`` 类型可以以牺牲精度为代价来换取节省内存占用，
这种做法在一些情况下是有意义的。
